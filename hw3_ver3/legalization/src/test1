
        sort_module_order();
        bool is_reverse_legal = false;
        init();
        while(1) {
            int nRow = (int)_placement.numRows();
            int counterTest = 0;
            for(unsigned& moduleID:_ordered_moduleIDs ) {
                cout << "counterTest: " << counterTest++ << endl;
                // cout << "moduleID:" << moduleID << endl;
                double best_delta_cost = numeric_limits<double>::max();
                double y_g = _cLegal.m_globalLocations[moduleID].y;
                unsigned y_begin_idx = floor( (y_g - _placement.boundaryBottom()) / _placement.getRowHeight() );
                bool row_increase = true;
                unsigned rowCounter = 0;
                int rowIdx;
                int best_row_Idx = -1;
                while(1) {
                    rowIdx = y_begin_idx + ( row_increase ? rowCounter : -rowCounter );
                    ++rowCounter;
                    if ( rowIdx < 0 || rowIdx == nRow ||
                     best_delta_cost < pow( _placement.boundaryBottom() + rowIdx * _placement.getRowHeight() - y_g ,2 ) ) {
                        if ( row_increase )
                        {
                            row_increase = false;
                            rowCounter = 1;
                            continue;
                        }
                        else
                            break;
                    }
                    if ( _remain_widths[rowIdx] < module(moduleID).width() )
                        continue;
                    saveRow(rowIdx);
                    if (is_reverse_legal)
                        placeRow_reverse(rowIdx, moduleID);
                    else
                        placeRow(rowIdx, moduleID);
                    double newCost = rowCost(rowIdx);
                    if ( newCost - _cost[rowIdx] < best_delta_cost ) {
                        best_delta_cost = newCost - _cost[rowIdx];
                        best_row_Idx = rowIdx;
                    }
                    restoreRow(rowIdx);
                }
                assert(best_row_Idx>=0);
                if (is_reverse_legal)
                    placeRow_reverse(rowIdx, moduleID);
                else
                    placeRow(rowIdx, moduleID);
                _remain_widths[best_row_Idx] -= module(moduleID).width();
                _cost[best_row_Idx] += best_delta_cost;
                /////////////////////////////////
                if (! ( _cost[best_row_Idx] - rowCost(best_row_Idx) < 0.001 ) ){
                    cout << "_cost[best_row_Idx]" << _cost[best_row_Idx] << endl;
                    cout << "rowCost(best_row_Idx)" << rowCost(best_row_Idx) << endl;
                    exit(0);
                }
            }
            if (is_reverse_legal)
                break;
            else {
                break;
                is_reverse_legal = true;
                vector<unsigned> tmp = _ordered_moduleIDs;
                unsigned n = tmp.size();
                for (unsigned i = 0; i < n; ++i)
                    _ordered_moduleIDs[n-i-1] = tmp[i];
            }
        }
        setBestPosition();

